<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机 on 老实人</title>
    <link>/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/</link>
    <description>Recent content in 计算机 on 老实人</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 23 Mar 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>哈夫曼树与编码的一些笔记</title>
      <link>/2018/10/18/huffman/</link>
      <pubDate>Thu, 18 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/10/18/huffman/</guid>
      <description>这是一篇没有技术含量的文章&amp;hellip;
 数据压缩 &amp;ndash; 哈夫曼（Huffman） 关于哈夫曼编码与哈夫曼树的一点简述 哈弗曼树也叫作赫夫曼树，也叫作霍夫曼树，都指的是同一个玩意儿. 首先说哈夫曼树吧，哈夫曼树是一种特殊的二叉树，它设计的二进制前缀的编码在通信领域有着广泛的应用。 哈夫曼编码可以极大的节省数据占用的空间，且压缩的效果是无损压缩，根据数据类型的不同，压缩率也将不同。
哈夫曼树(Huffman Tree)的构建步骤  将给定的n个权值看做n棵只有根节点（无左右孩子）的二叉树，组成一个集合HT，每棵树的权值为该节点的权值。 从集合HT中选出2棵权值最小的二叉树，组成一棵新的二叉树，其权值为这2棵二叉树的权值之和。 将步骤2中选出的2棵二叉树从集合HT中删去，同时将步骤2中新得到的二叉树加入到集合HT中。 重复步骤2和步骤3，直到集合HT中只含一棵树，这棵树便是赫夫曼树。  哈夫曼树有以下几种特性   根据节点的个数以及权值的不同，赫夫曼树的形状也各不相同，赫夫曼树具有如下特性：
  对于同一组权值，所能得到的赫夫曼树不一定是唯一的。
  哈夫曼树的左右子树可以互换，因为这并不影响树的带权路径长度。
  带权值的节点都是叶子节点，不带权值的节点都是某棵子二叉树的根节点。
  权值越大的节点越靠近赫夫曼树的根节点，权值越小的节点越远离赫夫曼树的根节点。
  哈夫曼树中只有叶子节点和度为2的节点，没有度为1的节点。
  一棵有n个叶子节点的赫夫曼树共有2n-1个节点。
  哈夫曼编码 哈夫曼编码是在哈夫曼树的基础上进行的二进制编码，首先将频率高的放在右边标号为1，频率低的放在左边标号为0，编码原理是根据根节点到子节点经过的距离编码而成，我也不知道该如何表述其原理，具体看下图吧。
首先给定五个字符，而字符旁边的数字代表该字母出现的次数，依据上述的规定条件，我将其集合中最小的两个值放在一起组合成一个二叉树，计算其两个值的和，往复循环。
根据图中所得：
 X=0 E=10 V=111 A=1100 B=1101 哈夫曼编码的效率计算是通过每个权值到根节点经过了多少条线相乘，再加上其他权值与根节点的距离相乘，以此反复直到结束计算出压缩后的大小。
在通常情况下，霍夫曼编码并不是最高效的压缩方法，但它压缩和解压缩的速度非常快。一般来说，造成霍夫曼编码比较耗时的原因是它需要扫描两次数据：一次用来计算频率，另一次才是用来压缩数据。而解压缩数据非常高效，因为解码每个符号的位序列只需要扫描一次霍夫曼树。
Python代码实现Huffman编码(网摘) import queue class HuffmanNode(object): def __init__(self, left=None, right=None, root=None): self.left = left self.right = right def children(self): return((self.</description>
    </item>
    
    <item>
      <title>关于计算机并发与并行的一些记录</title>
      <link>/2018/07/07/serial_parallel_concurrent/</link>
      <pubDate>Sat, 07 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/07/07/serial_parallel_concurrent/</guid>
      <description> 这是一篇没有技术含量的文章&amp;hellip;
 1.进程   计算机中每个程序都可以叫做进程，一个QQ，一个Chrome浏览器，他们会在内存中划分一块属于自己的空间，一个进程中可以包含多个线程。所谓进程，它是动态的，是一个在运行当中的程序，而程序只是保存在硬盘当中一段可执行的代码。如果细说其进程的构造，可分为如下：
  Linux进程结构：可由三部分组成：代码段、数据段、堆栈段。也就是程序、数据、进程控制块PCB（Process Control Block）组成。进程控制块是进程存在的惟一标识，系统通过PCB的存在而感知进程的存在。
  代码段存放程序的可执行代码。数据段存放程序的全局变量、常量、静态变量。堆栈段中的堆用于存放动态分配的内存变量，堆栈段中的栈用于函数调用，它存放着函数的参数、函数内部定义的局部变量。
   系统通过PCB对进程进行管理和调度。PCB包括创建进程、执行程序、退出进程以及改变进程的优先级等。而进程中的PCB用一个名为task_struct的结构体来表示，定义在include/linux/sched.h中，每当创建一新进程时，便在内存中申请一个空的task_struct结构，填入所需信息，同时，指向该结构的指针也被加入到task数组中，所有进程控制块都存储在task[]数组中。  2.并发编程又叫多线程编程   在程序中，往往有很多很耗时的工作，比如上传文件、下载文件、跟客户聊天需要长时间建立连接(socket)。这种时候，一个线程是服务不了多个用户的，会产生因为资源独占产生的等待问题。并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。（买票问题并发进行）
  并发当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间 段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。.这种方式我们称之为并发(Concurrent)。
  3.并行  指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。（hadoop集群就是并行计算的） 当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。   并发和并行
  并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可以同时执行。  4.串行、并行  并行和串行指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。并行指的是多个任务可以同时执行，异步是多个任务并行的前提条件。  5.同步、异步   指的是能否开启新的线程。同步不能开启新的线程，异步可以。
  异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。
  异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。
  6.多线程  多线程是程序设计的逻辑层概念，它是进程中并发运行的一段代码。多线程可以实现线程间的切换执行。  </description>
    </item>
    
  </channel>
</rss>